---
sidebar_position: 11
---

# LT-EX-2 处理竞态条件

## 从一到多

Minecraft 多人游戏中最有趣的地方（恐怕也是造成最多麻烦的地方）就在于它**多人**的特性，在插件中尤其如此 —— 当某一段代码在运行时，服务器上可能有其它的代码也**同时在运行**，它们可能来自其它插件，也可能是你的插件的另一部分，甚至可能是同一部分代码针对不同的玩家（或者区块、物品什么的）执行的结果！

当有多段代码在同时运行时，**竞态条件（Race Condition）** 就成为一个很容易发生的问题。顾名思义，竞态条件指的是有两段或更多代码竞争地访问同一份资源。编写代码的人如果不仔细考虑程序的其它部分（甚至可能是同一部分的不同情况）对当前代码的影响，就很容易出现漏洞。

在这个插件里，竞态条件问题也是存在的，请看下面的操作序列：

1. 管理员 A 输入 `/kitmod` 打开编辑器。
2. 管理员 B 同样打开编辑器。
3. 管理员 A 完成编辑并关闭物品栏，`kitItems` 的值被更新。
4. 管理员 B 完成编辑并关闭物品栏，`kitItems` 被修改为管理员 B 的版本，A 所做的修改就丢失了。

像这样的**不一致性（Inconsistency）** 是竞态条件问题产生的主要后果之一，管理员 A 修改并保存了物品栏，但这样的修改**并不是立即对 B 可见的**，B 看到的仍然是最开始版本的 `kitItems`，因此稍后 B 保存修改时，A 的修改就会被覆盖。

## 某时、此时

更一般地来说，竞态条件是由**多个事务同时访问一些共享的资源**而导致的，**事务（Transaction）** 可以简单理解为“一系列操作”，也就是说，如果有多段代码（或者同一段代码在多处执行）在操作同样的一件东西，那么它的**状态就随时可能变化**。

由于 Minecraft 单线程的特性，一般应用程序中多线程导致的问题在 Minecraft 中（至少在游戏逻辑的意义上）并不是那么频繁，但竞态条件漏洞仍然可能出现。事实上，竞态条件漏洞的出现只需要以下两个条件：

- 有多个事务访问同一份资源。
- 程序没有注意到“在执行期间，该资源可能发生变化”的事实。

这两个条件也正是破解竞态条件漏洞的两种方法：

- 限制多个事务同时访问资源，或者将资源复制多份。

  这是最简单的方法 —— 如果每个资源仅由一个事务访问，那么从源头上就不可能出现“多人哄抢”的情况。然而，这么做会大幅降低系统的性能，例如在像全球市场一类的插件中，“当有玩家在选购时，其他玩家必须等待”压根就是不现实的事情。

- 及时跟进和处理共享资源的变化。

  这是所有竞态条件问题的通用解法，比如在购票软件中，用户选座时会显示座席列表，在稍后付款时，系统可能会再次检查，确定对应的座席仍有余票，这可以避免“两人付款但只有一个座位”这样的情况。然而，要在高并发（有很多事务同时发生）时及时同步变化，会让代码变得更加复杂，而且容易引发衍生的漏洞。

理论上来说，如果共享的资源在任何时刻都可能发生改变，那么要使用它的程序是没有办法确保它的状态的，要消除竞态条件也不可能做到。因此，在实际的实现中，程序或多或少都会在某个时刻**独占资源** —— 这没办法避免，但可以减少，“当有人买票付款时，拒绝其他人购买同一坐席”和“当有人打开购票界面时，拒绝其他人进入”是两种完全不同的概念（笑）。

大家可能会想，也许可以通过编写一些特殊的代码来实现“独占资源”，但其实没必要这么麻烦，因为 Minecraft 中执行的大多数代码都有一个很好的性质 ——

## 生而为一

细心的读者应该回想起来，我们在区块过热插件中，似乎也应该有竞态条件：

```kotlin
val prevHeat = chunk.persistentDataContainer.get(heatKey, PersistentDataType.INTEGER) ?: 0
// ...
chunk.persistentDataContainer.set(heatKey, PersistentDataType.INTEGER, newHeat)
```

我们同样是先读取 PDC 中的热量值，然后计算出新的热量，再将它设置回去。在这些操作中间，PDC 中的值是否有可能发生变化？也就是说，下面这样的事情会不会发生：

1. 实体 A 生成，读取 PDC 中的热量，假设为 `5`。
2. 实体 B 生成，读取 PDC 中的热量，同样为 `5`。
3. 实体 A 的事件处理完成，新热量 `6` 被存入 PDC。
4. 对热量的修改在 B 中不可见，B 同样将新热量 `6` 存入 PDC。

由于生成了两个实体，PDC 中理论上应该存储着 `7` 而不是 `6`，这就导致了不一致性。问题在于，这样的情况可能发生吗？

答案是否定的，因为事件处理函数是**原子的（Atomic）**。原子的意思就是**不可分割**，也就是说，事件处理函数的代码就像一个整体一样，在它执行时，任何其它操作都不能插入到其中。换句话说，读取 PDC、计算新值、写回 PDC 三个操作是**连续进行**的，如果有其它的代码修改 PDC，它要么在这个操作序列之前进行，要么在它之后进行，但不可能在执行完了一个或两个操作后“打断”正在执行的事件处理函数。

在 Bukkit 中，大多数和游戏逻辑相关的代码都是原子的，例如事件处理函数、命令处理函数、实体 AI、药水效果等。形式化（但是不严谨）地说，**如果你写出来的代码是连续的，那么它大概率在执行上也是连续的**。

*事实上，任何在游戏线程上执行的代码，对于游戏线程上其它的代码而言也都是原子的，但要介绍这部分内容需要涉及 Bukkit 的线程模型，必须挪到后续章节了。*

在初始套装插件中，情况就变得不一样了，因为“显示编辑物品栏”和“保存编辑结果”发生在**不同的地方**：编辑物品栏通过命令处理函数打开，而保存编辑结果却是在 `InventoryCloseEvent` 的事件处理函数中处理的。因此，显示编辑器、等待用户编辑和保存编辑结果这个操作序列是**非原子的**。在编辑器打开但尚未保存前，初始套装的内容有可能会发生变化，比如其他管理员进行修改，而这样的修改却并**不能立即反映**到当前的物品栏中。

要解决这个问题有两种方法：

- 把编辑过程变得原子化，当有人正在编辑物品栏时，拒绝其他人开始编辑。
- 当有人修改了初始套装时，相应地更新其他编辑者的物品栏。

在这里我们采取第一种方法，因为它更容易实现，而且“多人同时编辑”是一个少见的情况，即使暂时阻止其他管理员编辑，也不会带来太大的影响。第二种方法虽然看上去效果更好，但实现起来会更困难：怎样才算“相应更新”？玩家如果手上正拿着一个物品怎么办？玩家放入的物品是否会被更新覆盖掉？这会引发更多的竞态条件问题。

*实际上，要实现方案二也是可以办到的，但这需要我们修改编辑器的代码，使用一种被称为“日志式修改”的技术，这属于高阶内容，要放在下一话中介绍。*

## 锁定、解锁

将非原子化的事务变得原子化的最简单方法是使用**锁（Lock）**，或称**互斥锁（Mutex）**。这里的锁不是指某个具体的类或者函数，而是一个标志，就像交通信号灯一样 —— 当红灯亮起时，对应方向上的车辆必须等待。

<details>
<summary>你是职业选手吗？</summary>

事实上 Minecraft 的游戏线程并非多线程环境，因此在这里用专用于并发同步控制的“互斥锁”一词不是很恰当。由于将非原子化操作变为原子化的过程涉及的标志机制与互斥锁非常类似，因此我们借用该词来描述，读者在理解了这样的工作原理后，在接触并发环境下真正的互斥锁时不会感到困惑。

</details>

锁的最基本使用方式是在**需要独占访问**而又**非原子化**的区间设置标记。在本例中，“读取并显示编辑器”和“保存编辑内容”分别都是原子的，因为它们分别在各自的命令处理函数和事件处理函数中执行，但在这两个操作之间，即“等待玩家完成编辑”这个时间区间，我们的事务是非原子的，其它代码可以更改 `kitItems`。因此，我们需要在这个区间内增加一个锁，告诉其它代码：“有人正在使用 `kitItems`，请等一下！”

把这个任务分配到相应的操作中，我们就得到如下的编辑操作序列：

- 当 `/kitmod` 执行时，检查是否锁定：
  - 如果锁定，则拒绝开始编辑，并报告错误。
  - 否则，加锁，并显示编辑物品栏。
- 当编辑物品栏关闭时，解锁，并保存物品栏。

也就是说，我们在打开编辑物品栏时申请独占 `kitItems`，并在保存时结束该独占操作。如果不能做这样的申请，那么继续修改是不安全的，应该主动放弃。

设计做好后，代码编写起来是很容易的，首先增加一个变量，标记是否有人正在编辑：

```kotlin
class Liftoff : JavaPlugin() {
    // ...
    private var isEditing = false
}
```

然后在命令处理函数和事件处理函数中，相应修改这个变量：

```kotlin
server.getPluginCommand("kitmod")?.setExecutor { sender, command, label, args ->
    if (sender is Player) {
        if (sender.isOp) {
            // 新增的代码
            if (isEditing) {
                // 有人正在编辑，拒绝打开编辑器
                sender.sendMessage(Component.text("Another edit operation is in progress, please wait."))
            } else {
                // 正常打开编辑器
                isEditing = true    // 加锁

                val inv = KitModInventoryHolder()
                // ...
            }
        } else {
            // ...
        }
    }

    true
}
```

```kotlin
fun onInventoryClose(ev: InventoryCloseEvent) {
    // ...
    ev.player.sendMessage(Component.text("Kit content altered."))
    isEditing = false   // 解锁
}
```

做了这样的修改后，我们确信“多人修改时先进行的修改会被覆盖”这个问题已经被修复，所以让我们在服务器上验证一下。启动服务端，然后启动两个客户端，分别登录不同的帐户（如果你只有一个微软帐户，可以考虑使用第三方帐户或者离线帐户），尝试同时打开编辑物品栏，你会发现只有先执行命令的客户端能够编辑，而后执行命令的需要等待。

:::note

细心的读者可能会担心，“如果玩家不关闭物品栏而离开服务器，会不会出问题？”这样的想法是有道理的，而且对于一些事件来说还真就是这样，不过对于 `InventoryCloseEvent` 而言，当玩家离开服务器时，Bukkit 会自动关闭物品栏，并触发 `InventoryCloseEvent`，因此就不需要单独处理玩家退出的情况。

:::

---

这样我们就算解决了这个漏洞！说是**解决（Mitigate）** 而非**修复（Fix）**，是因为我们并没有真正意义上妥善处理“多个玩家打开物品栏”的情况，而只是简单阻止了这种情况的发生，有“头痛砍头”之嫌。这都是由于我们在一开始设计“物品编辑”这个功能时考虑得不够周到，所设计的算法太过简单，事到如今只好采取这样的方式。

事实上，这样修修补补的情况在各种项目中都存在，尽管有很多方式能延缓这一过程，但代码质量**随着项目发展而降低**是不可避免的。当项目中代码的问题积累到一定的程度，开发者就必须重新思考项目的结构和各项功能的实现，并重新编写一部分代码来改善代码质量，这个过程被称为**重构（Refactor）**。重构代码是软件开发中最艰苦的工作，但由于它是几乎唯一能解决历史遗留问题的方法，至今仍在许多大型项目中使用，并由此衍生了许多相关的工具 —— 有机会一定向大家介绍一下（笑）。
