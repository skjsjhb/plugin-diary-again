---
sidebar_position: 4
---

# KT-8 Kotlin 泛型

## 很多很多的类

你已经知道 YAML 中的列表，它们能用来存储一组值：

```yaml
my-key: [1, 2, 3]
my-another-key:
    - "some-string"
    - "ciallo-world"
```

如果想在 Kotlin 中用类来描述它们（因为 Kotlin 中的一切都是对象），该怎么做？由于 `my-key` 和 `my-another-key` 中存储的**数据类型不同**（一个是数，一个是字符串），只用一个类来包含这些数据，肯定是不够的。

回想一下我们能使用 `getInt` 和 `getString` 获取不同数据类型的值，那么我们可以如法炮制，定义出下面这样的两个类：

```kotlin
class IntList {
    // ...

    fun getFirst(): Int = // ...
}

class StringList {
    // ...

    fun getFirst(): String = // ...
}
```

我们定义两个类来分别描述数字列表和字符串列表，这么做是有道理的 —— 你可以看到它们其中的 `getFirst` 方法，一个返回 `Int`，一个返回 `String`，这是**根据列表中对象的类型**而决定的。如果使用一个类，就做不到这一点。

这么做的问题也很明显：对于每个不同的类型，我们都需要**创建一个单独的类**。如果我们还想要存储其它类型呢？比如 `Player`、`ItemStack` 或者 `Block`？这就得编写很多很多的类！

事实上，这样的重复根本是没有必要的，因为列表类中大多数的代码都相同，仅仅是其中所“包含”的类型不一样而已。也就是说，仅仅是为了一些形式主义的工作，我们就又得复制粘贴代码，而且由于方法返回值不同，就连强大的继承对此也无能为力。

## 把类型当作参数

设计 Kotlin（和 Java）的人为了解决这个问题，就发明了**泛型（Generics）** 系统，泛型允许我们**把类型当作参数**，动态地使用类型信息。

用泛型来改写上面的例子，就会变成这样：

```kotlin
class List<T> {
    // ...
    fun getFirst(): T = // ...
}

val a: List<Int>    // 等效于原先的 IntArray
val b: List<String> // 等效于原先的 StringArray
```

位于类名 `List` 之后的尖括号 `<>` 内的就是**类型参数（Type Parameters）**，虽然被称作参数，但它们和函数的参数还是有些不一样，因为它们并不代表什么具体的值，你也不能把 `T` 赋给某个变量，它们只是**某个类型的别名**，比如 `Int` 和 `String`。

在定义了类型参数后，我们就可以在整个类的定义当中使用 `T` 作为类型，和使用 `Int` 这样的具体类型没什么区别。稍后，我们可以使用这种具有泛型的类，只需要提供对应的类型参数（例如 `List<Int>`），Kotlin 就会自动把 `Int` 代入 `T`，计算出整个类中所有方法和属性的类型。

*所以说到底，泛型所做的其实就是动态地为我们“生成”了一个像是 `IntList` 这样的类而已（当然除此之外还有其它的好处）。*

类型参数可以使用一个或者多个。另外，类型参数不仅可以施加在类上，也可以施加在方法上，只需要在合适的地方加上 `<>`：

```kotlin
fun <P, Q> compare(a: P, b: Q): Boolean {
    // 这里可以使用 T
}

val x = 1
val y = 2
compare<Int, Int>(x, y)
compare(x, y)       // Int 也可以省略，Kotlin 会自动推断
```

在方法中使用类型参数和在类中使用基本没什么区别，不过定义时类型参数写在方法名的前面，而调用时却写在后面，这一点确实有些奇怪（笑）。

