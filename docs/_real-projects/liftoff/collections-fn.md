---
sidebar_position: 6
---

# KT-10 Kotlin 集合类（下）

## 遍历访问

### 一般遍历

除了针对集合类中某个特定元素进行访问外，集合类的另一大常用用途是**遍历（Iterate）**。所谓遍历，其实也就是“逐个访问每个元素”。

在 Kotlin 中，最直接的遍历方法是使用 `for` 循环，术语称作**遍历循环（Iterating Loop）**：

```kotlin
val roList = listOf(1, 2, 4, 16, 32)

for (ele in roList) {
    println(ele)    // 输出 5 次，分别是 1, 2, 4, 16, 32
}
```

在 `in` 之前的 `ele` 被称作循环变量，`for` 按次序逐个**把各个元素赋给 `ele`**，并执行 `{}` 中的代码。

<details>
<summary>你是职业选手吗？</summary>

Kotlin 舍弃了 C 和 Java 中的条件循环（同样名为 `for`），也就是这样的写法：

```c
for (int i = 0; i < arr_len; i++) {
    puts(arr[i]);
}
```

在 Kotlin 中，`for` 只能用来遍历某个集合，如果想要像上面那样指定索引，就需要使用**区间表达式（Range Expression）**：

```kotlin
for (i in 0 ..< arr.size) {  // 0 到 arr_len，但是不含 arr_len
    println(arr[i])
}
```

或者改写为等效的 `while` 循环：

```kotlin
var i = 0
while (i < arr.size) {
    println(arr[i])
    i++
}
```

不过像这种基于索引的遍历方式，在 Kotlin 中非常少见。最好是直接对集合类进行遍历，或者使用相应的扩展函数。

</details>

像上面这样的 `for` 写法还是太麻烦了，我们又要给循环变量起名，还得费劲地把光标在 `{}` 之间挪来挪去。大多数 Kotlin 工程师都会使用下面这样的写法：

```kotlin
roList.forEach {
    println(it)
}
```

`forEach` 是 `List` 的一个方法，它接受一个函数（可以是 Lambda），并**对每个元素调用一次指定的函数**，其中元素作为该函数的唯一一个参数。也就是说，我们只需要告诉 `forEach`：“我们想对每个元素这样做”，`forEach` 就会把我们的“操作”对每个元素施加一遍。这和 `for` 的功能基本相同，但写起来就要方便多了，大家可以在 IDEA 中试一试。

### 转换遍历

`forEach` 还有个变种 `map`，它的功能与 `forEach` 差不多，不过它还会把函数的返回值**收集起来**，组成一个新的 `List`，看上去就像把一个集合类**转换**成一个 `List` 一样：

```kotlin
roList.map { it * 2 }   // 2, 4, 8, 32, 64
```

在这里，由于 `it * 2` 就是 Lambda 的最后一个表达式，它自动成为 Lambda 的返回值，所以这个 Lambda 的功能就是“返回指定元素翻倍后的值”，程序整体的功能就是“把每个值翻倍，组成一个新的 `List`”，就这么简单！

:::warning

`map` 依照遍历的次序收集返回值，因此不论是映射表、集合还是列表，最终的产物都是 `List`，尽管映射表和集合被遍历的顺序可能是不确定的。

:::

`map` 还有个变种 `mapNotNull`，它的功能和 `map` 非常相似，但如果我们的函数返回 `null`，它就跳过这个返回值。这允许我们从结果中丢弃掉一些不需要的值，而不在生成的 `List` 中包含不必要的 `null`。

### 过滤遍历

Kotlin 提供了 `filter` 来**过滤**集合类：

```kotlin
roList.filter { it > 2 }    // 4, 16, 32
```

`filter` 同样接受一个 Lambda，对每个元素调用一遍，同时只保留使得 Lambda 返回 `true` 的元素。也就是说，`filter` 只保留**符合指定条件**的元素。这个操作非常实用，比如当我们想找出生命值高于 10 的玩家时，就可以这么做：

```kotlin
players.filter { it.health > 10.0 }
```

`filter` 还有几个变种：`filterNot`、`filterNotNull`、`filterIndexed`、`filterIsInstance` 等，它们的功能可以简单“望文生义”，这里就不再赘述了，大家可以在 Kotlin 的文档中找到相应的内容。

### 判定遍历

Kotlin 提供了 `all` 和 `any` 来判断集合类是否满足某个条件，这两个函数都返回 `Boolean` 值：

```kotlin
roList.all { it > 0 }   // true，每个元素都大于 0
roList.any { it > 100 } // false，并没有一个元素大于 100
```

`all` 判定**每个**元素都符合指定条件，`any` 判定**至少有一个**元素符合指定条件。

*严格一点来说，`all` 判定“没有哪个元素不符合指定条件”，因此对于空白的集合类，`all` 会返回 `true`。*

:::warning

`all` 和 `any` 不保证会访问每个元素，如果它们找到了足以下结论的元素，则可能会提前返回。Kotlin 并未规定这种情况下它们的具体行为，因此不应假定所提供的 Lambda 会对每个元素至少调用一次。

:::

### 查找遍历

Kotlin 提供了 `find` 来寻找**第一个**符合条件的元素，它是 `any` 的强化版本：

```kotlin
roList.find { it > 2 }   // 4
roList.find { it > 100 } // null，因为没有这样的值
```

`find` 还有一个变种 `findLast`，它返回最后一个符合条件的元素（倒序版的 `find`）。

## 组合与转换

### 元素组合

我们已经知道 `add` 可以向集合类中添加元素。如果我们想要把两个列表合成一个，但不希望改动原来的列表，该怎么做？其实非常简单：

```kotlin
val al = listOf(1, 2, 3)
val bl = listOf(4, 5, 6)
al + bl     // 1, 2, 3, 4, 5, 6
```

和字符串一样，只需要使用 `+`，我们就得到一个**新的列表**，包含两个列表中的所有元素。更妙的是，`+` 不仅可以用在两个列表之间，也可以用在列表与集合之间，等等。只要两个集合类所包含的元素相同，即使它们自身的类型不同，也可以这样拼接。

除此之外，`+` 还可以用来拼接集合类与单个元素：

```kotlin
al + 6  // 1, 2, 3, 6
```

:::warning

集合类的 `+` 是不满足交换律的 —— 两个集合类的拼接顺序影响它们最终产物的顺序，而集合类与元素拼接时，必须把集合类放在前面。

:::

### 集合转换

Kotlin 提供了一些函数，用以在不同的集合类之间转换：

- `toList`：转换为只读列表。
- `toSet`：转换为只读集合。
- `toTypedArray`：转换为数组。

其中 `toList` 和 `toSet` 还有对应的可修改变种，即 `toMutableList` 和 `toMutableSet`，它们返回的值是可写的。

:::warning

这些方法不会修改原有的集合类，而是根据其中的元素，创建一个新的符合条件的集合类。这种操作是有代价的，在有大量元素时需要谨慎考虑。

基于同样的原因，像 `toSet` 这样的转换不是无损进行的，重复的元素会被丢弃，并且取决于实现，元素可能失去它们之间的顺序，即使使用 `toList` 转换回来也是如此。

:::

## 链式调用

我们已经提到过**链式调用（Chained Calls）** 这个概念了，就是连续地调用一个方法返回值的方法，这种模式经常用于**逐步处理对象**：

```kotlin
// 先这样，再那样，一定要注意这样，最后再这样……
ev.player
  .name
  .uppercase()
  .plus("!!")
  .let { println(it) }
```

如果有些操作本身不支持链式调用（例如 `println`），可以像上面那样用 `let`、`run`、`apply` 和 `also` 把它们转换成链式调用，这可以避免不必要的中间变量：

```kotlin
// 先这样，再那样 —— 诶不对不对，在这之前要这样，还要这样……
val loudName =  // 一开始是没有这一行的
ev.player
  .name
  .uppercase()
  .plus("!!")   // 当你写到这里时，你会发现不得不把光标挪回第一行，并添加 `val`

println(loudName)
```

……或者更可怕的括号地狱：

```kotlin
// 我是谁，我在哪，我为什么要在各种地方加括号和缩进……
println(
    toUppercase(
        ev.player.name
    ) + "!!"
)
```

有了链式调用，上面这种令人头疼的问题就可以解决，我们只需要重复“按下 `.`，选择一个合适的方法，添加参数”这个过程就可以了，完全不用到处挪动光标，这会让代码的编写快上不少。

集合类作为许多 Kotlin 程序中的重要部分，当然也能很好地和链式调用组合起来：

```kotlin
roList.filter { it > 2 }    // 4, 16, 32
      .map { it * 2 }       // 8, 32, 64
      .plus(128)            // 8, 32, 64, 128
      .find { it > 60 }     // 64
      ?.let { println(it) } // 64，加上 ? 是因为逻辑上 find 可以返回 null
```

*`plus` 是 `+` 的函数版本，因为直接使用 `+` 需要在两侧加上括号（`.` 的优先级比 `+` 更高，从而 `a + b.c` 和 `(a + b).c` 不同）。*

能像这样编写代码为我们提供了一种新思路，即不需要考虑一个元素怎么一步到位变成最终的值，而可以**逐步**对集合类中的元素进行处理，在这个过程中逐渐贴近并达成最终的目标。在许多实际项目中，这种方法会让程序设计和编码更加简单。

:::info

如果集合中的元素非常多，由于 `filter`、`map` 等方法每次都产生一个新的 `List`，这可能会影响程序的性能，此时可以使用 `Sequence` 来解决：

```kotlin
veryLargeList.asSequence()  // 转换为 Sequence
             // ...         // 进行一系列操作
             .toList()      // 转换回 List
```

`Sequence` 不会每次都产生中间结果，而是在最终求值的时候才进行运算，具体的原理可以参考 [Kotlin Sequence 介绍](https://kotlinlang.org/docs/sequences.html)。

:::

---

关于集合类和它们的扩展函数真是讲也讲不完，实际上除了 `List` 和 `Set`，Kotlin 还提供了很多有用的类型，比如 `Queue`、`Sequence`、各种 `Iterable`、`Range` 等。就连 `List` 和 `Set` 本身也有很多不同的实现，而且它们在功能和性能上都不尽相同。除此之外，Kotlin 还有 `flatMap`、`zip`、`associate`、`maxBy`、`sorted` 等各种方便的操作，我们会在后面的项目中见到其中一部分。

尽管笔者很想把这些全部拿出来说道一番，但仅仅是有关 Kotlin 的内容就能拿出来写上好几本书，考虑到本书毕竟是插件开发教程而不是 Kotlin 教程，限于篇幅，只能就此打住了（笑）。不过互联网上还有很多优质的资料，如果读者想进一步了解，可以通过搜索引擎来找到更多参考。