---
sidebar_position: 2
---

# LT-2 神奇妙妙背包

## 不过是一组格子！

要向玩家发放物品，我们就需要与玩家的**物品栏**进行交互。

许多游戏性插件或多或少都牵涉到物品栏的使用 —— 我们在旅行背包插件中已经这么做过了！遗憾的是，在那里我们只是对“怎么存储物品栏的内容”做了个粗略的介绍，大家对于如何操作物品栏本身肯定还是满头雾水。

其实，物品栏本质上就是**一列有序排列的物品**。肯定有读者要提出质疑，“箱子里不是 3 × 9 的阵列吗？”从游戏中来看的确如此，不过在 Minecraft 内部，物品栏是**一维**的 —— 第一行的物品按顺序编号为 0 至 8，第二行 9 至 17，以此类推。没有任何物品的空格子也占用一个位置。

![Inventory Index](/img/s3/inv-index.png)

既然每个格子都有唯一的编号，那么我们就可以通过这个编号来访问对应的物品，比如把 0 号位置物品的数目加倍，将 4 和 5 号位置的物品交换，删除 26 号位置上的物品，等等。

几乎所有涉及物品栏内容的操作都是通过 `Inventory` 接口完成的，这个接口提供了 `addItem`、`setItem` 和 `getItem` 三个基本方法来操作物品栏中的物品：

```kotlin
player.inventory.let {
    it.setItem(0, null)         // 清空第一个格子中的物品
    it.getItem(0)               // null
    it.addItem(someDiamonds)    // 向物品栏中添加物品 
}
```

`addItem` 方法很聪明，它会在物品栏中找到可用的格子，并将指定的物品加入其中，同时还会告诉我们哪些物品没有成功添加，这用于修改背包之类的功能是再方便不过了！

## 磐蟹、小花

*（嘟噜着气泡的苏打）*

既然能访问物品栏，我们就想要向其中添加点什么东西。要做到这一点，我们需要先弄清楚**物品**在游戏中的表现方法。其实，物品在 Minecraft 内部的存储方式和直观上看来差不多，包含三部分的信息：

- **材料**，即“这个物品是什么”，比如纸、草方块等。

  <details>
  <summary>你是职业选手吗？</summary>

  与模组开发不同，由于插件本身不涉及“添加新方块”之类的操作，游戏中所有存在的物品一开始就是已知的，因此一个物品的所有性质几乎完全**由其材料决定**。只要指定对应的材料，Bukkit 就知道你想要使用哪个物品。

  </details>

- **数量**，即物品的剩余数目 —— 那个平时显示在物品右下角的数字。

- **属性**，即物品具有的额外信息。有些物品可能比其它物品拥有更多的信息，比如书与笔额外存储着书中的内容、药水存储着药水效果等。

在 Bukkit 中，物品是通过 `ItemStack` 类来描述的，要构造和使用物品非常简单：

```kotlin
ItemStack(Material.DIAMOND, 64).let {
    it.amount   // 64
    it.addEnchantment(Enchantment.INFINITY, 1)  // 添加附魔
    it.editMeta {   // 修改物品信息
        // 这里的 it 指的是获取到的 ItemMeta，而不是外层的 ItemStack
        it.customName(Component.text("古灵精怪 ★ 魔法石")) // 设置自定义名称
    }
}
```

其中 `editMeta` 是一个比较有趣的方法，它希望我们提供一个函数，描述**打算对物品信息做什么**，而它会将物品信息（包含在 `ItemMeta` 接口中）传递给这个函数来实现我们的想法。大家肯定会想“哎呀，这样好麻烦，为什么不能直接通过 `it.itemMeta.xxx` 修改物品信息呢？”。的确，这么做是不太方便，但 Paper 这么设计并非毫无理由，如果你想知道的话，答案在下面。

:::info 在过去

和先前提到的 `velocity` 一样，Bukkit 在获取物品信息（即使用 `itemMeta` 属性）时会返回物品信息的一个**副本**，直接修改这个对象是没有任何效果的，必须通过 `setItemMeta`（对应着 Kotlin 中的赋值）才能把修改“应用”到物品当中。这么设计的原因有很多，包含 Minecraft 内部格式与 Bukkit 格式的转换、旧版本数据升级、客户端同步问题等等。

这么做会带来些问题。当然，代码变复杂是肯定的，除此之外，直接获取 `ItemMeta` 也会有些类型转换上的问题（这一点会在稍后提到）。Paper 提供了方便的 `editMeta` 方法，允许我们传递一个函数直接修改物品信息，这样就方便了不少。

:::

## 存储物品数据

或许 Minecraft 的各类相关开发，从启动器到插件、模组、数据包，都绕不开“如何存储数据”这个永恒的话题。游戏的世界是立体的，但各种文件和数据库能存储的数据却是有限的。我们必须把游戏对象转换成能存储的格式，并且确保稍后还能恢复它们，这个过程叫做**序列化（Serialization）** 和**反序列化（Deserialization）**。

在旅行背包插件中，我们已经了解了如何使用 Bukkit 提供的方法，将物品栏的内容转换成 `ByteArray` 存入 MapDB。事实上，Bukkit 自身提供了另一种介质，它能够**直接存储** `ItemStack` 对象，并且还能方便地读取。大家肯定对这个“新英雄”好奇不已，不过它实际上只是我们的老朋友 —— 配置文件，或者更确切地说，是 YAML 文件。

*大家应该还没有忘记先前使用 MapDB 存储数据的原因 —— 玩家的背包数据可能很复杂，而且可能包含不安全的内容，不适合使用 PDC 或者 YAML 文件存储。不过，这可不代表 YAML 文件不能存储这些信息，只是在那种场合下不是最佳选择。*

Bukkit 的配置文件为物品、玩家档案、位置信息等 Minecraft 中经常存储的数据类型做了单独的适配，读写它们就和读写字符串什么的几乎完全相同，只需要使用相应的 `get` 方法：

```kotlin
val item = ItemStack(Material.POTION, 1)
item.editMeta {
    it.customName(Component.text("嘟噜着气泡的苏打"))
}

config.set("my-item", item)

val readItem = config.getItemStack("my-item")
readItem.customName()   // 会显示物品名称
```

Bukkit 会正确地处理这些数据，这么做 OK。